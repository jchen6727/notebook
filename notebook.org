* 8.5.19 Lots of errors due to using old version of NetPyNE (0.6.6)
Used SSH to access Neurosim
Downloaded implementation of Destexhe model in .hoc as well as NetPyNE
.hoc model demo runs without issue through NEURON GUI by using the command
nrngui then loading the demo file 
NetPyNE implementation ran into issues, first;

Traceback (most recent call last):
 File "init.py", line 1, in <module>
   import netParams  # import parameters file
 File "/home/jchen/CompNeuro/myKnoxRepo/netParams.py", line 142, in <module>
   cellRule = netParams.importCellParams(label='TCrule', conds={'cellType': 'TC', 'cellModel': 'HH_TC'}, fileName='TC.tem', cellName='sTC')
 File "/home/jchen/.local/lib/python2.7/site-packages/netpyne/specs.py", line 330, in importCellParams
   secs, secLists, synMechs = utils.importCell(fileName, cellName, cellArgs)
TypeError: 'NoneType' object is not iterable 

This error occurs whenever fileName references a .tem file, looking in the directory, all the .tem files with the exception of RE.tem have .py versions as well, when changing the netParams.importCellParams() call to use the .py version, no errors appear.
I am also told by Salvador that I should change the .tem files to end with .hoc and change the netParams.importCellParams function call to have fileName be referring to the newly named .hoc file
However, this causes an additional error to appear:

 Traceback (most recent call last):
  File "init.py", line 1, in <module>
    import netParams  # import parameters file
  File "/home/jchen/CompNeuro/myKnoxRepo/netParams.py", line 142, in <module>
    cellRule = netParams.importCellParams(label='TCrule', conds={'cellType': 'TC', 'cellModel': 'HH_TC'}, fileName='TC.hoc', cellName='sTC')
  File "/home/jchen/.local/lib/python2.7/site-packages/netpyne/specs.py", line 331, in importCellParams
    secs, secLists, synMechs = utils.importCell(fileName, cellName, cellArgs)
  File "/home/jchen/.local/lib/python2.7/site-packages/netpyne/utils.py", line 128, in importCell
    _delete_module(moduleName)
UnboundLocalError: local variable 'moduleName' referenced before assignment

This is because moduleName is only defined in utils.py if the fileName ends in .py or .hoc but is otherwise undefined

Found that my version of netpyne was 0.6.6 and this was fixed by updates, upgraded to netpyne 0.9.6 most recent version.

* 8.6.19 Updating everything but Lost lreadline
On laptop, after upgrading to netpyne 0.9.6 upgraded NEURON to 7.7.1 using their package manager, and upgraded ubuntu to LTS 18.0.4 which also had python 3.6.8, however, new upgrade lost libreadline shared object, nrnivmodl, nrngui, now fail to run properly without libreadline. Performed full reinstallation of OS Ubuntu 18.04 to laptop.
However, after full reinstallation, still having issues with -lreadline --
When running nrnivmodl:

/usr/bin/ld: cannot find -lreadline
collect2: error: ld returned 1 exit status
/usr/local/nrn/x86_64/bin/nrnmech_makefile:94: recipe for target 'libnrnmech.la' failed
make: *** [libnrnmech.la] Error 1

* 8.7.19 NEURON installation script shows where lreadline is. Things are running.
Reinstallation of NEURON this time not using package manager but by downloading the repo and running their scripts. The ./configure script put out this message

checking checking compilation with -lreadline... failed
Link with the readline library failed.
Will attempt to compile and link with the older version of readline
that comes with this installation. If this is not what you want, i.e.
you want to use the latest gnu version of readline and it
is not installed in a standard
place (e.g., /usr/lib or /usr/local/lib), you must specify the proper location
of libreadline using

  configure --with-readline=/where/you/put/it

The file libreadline.a (or libreadline.so or whatever) should be located in
/where/you/put/it/lib.

If you don't have readline installed, you can get it from the GNU web site,
www.gnu.org.

Other things to get prior to installation of NEURON include yacc and lex with 
sudo apt-get install flex bison
Remember to rerun from ./configure.sh properly or make will still fail to compile.
On the neurosim machine, found that a working NEURON-PYTHON environment was already established and could be accessed through 

conda activate py36

Ran both demos successfully without errors.
The code being executed by rundemo.hoc is found in Fspikewave.oc . The specific plots in the demo are 

i=watchneuron
    sprint(gtxt,"TC[%d].soma.v(0.5)",i)
    addgraph(gtxt,-120,40)
    sprint(gtxt,"RE[%d].soma.v(0.5)",i)
    addgraph(gtxt,-120,40)
    sprint(gtxt,"PY[%d].soma.v(0.5)",i)
    addgraph(gtxt,-120,40)
    sprint(gtxt,"IN[%d].soma.v(0.5)",i)
    addgraph(gtxt,-120,40)
addfieldgraph(“field”,-5,5)

or addgraph("TC[11].soma.v(0.5)", -120, 40) will add a graph.

* 8.8.19 Using older version of pandas, getting output waveforms
On personal laptop, ran into issue when running netpyne implementation

nrniv -python init.py

The issue is with module pandas, the latest version of pandas no longer has attribute lib which is used in netpyne. Am installing an older version of pandas

pip install pandas=0.23.0

Saved output waveforms to a .png 

The hoc implementation has the ability to model mutations and AEDs through nav_type and drug

if (nav_type == 1) {
//T857M
 for i=0, ncorticalcells * 2 - 1 {
   IN[i].soma.svhalf_inak2005mut = 61.6
   IN[i].soma.sk_inak2005mut = 3.7
   IN[i].soma.staubase_inak2005mut = (36200 / 106700) * 140400
   taummax = 0.15
   tauhmax = 23.12
   tausmax = (36200 / 106700) * 140400
 }
}

if (drug == 1) {
//carbamazepine
 print "carbamazepine"
 print dose
 gnablock_inak2005 = 1 - (1 - 0.763) * dose
 hshift_inak2005 = -7 * dose
 sshift_inak2005 = -4.63 * dose
 htaubase_inak2005 = tauhmax + tauhmax * (31.526 -1) * dose
 staubase_inak2005 = tausmax - tausmax * (1 - 0.5538) * dose


 for i=0, ncorticalcells * 2 - 1 {
   IN[i].soma.gnablock_inak2005mut = 1 - (1 - 0.763) * dose
   IN[i].soma.hshift_inak2005mut = -7 * dose
   IN[i].soma.sshift_inak2005mut = -4.63 * dose
   IN[i].soma.htaubase_inak2005mut = tauhmax + tauhmax * (31.526 -1) * dose
   IN[i].soma.staubase_inak2005mut = tausmax - tausmax * (1 - 0.5538) * dose
 }
}

Plan to move these mutations to the NetPyNE implementation.
However, first, there is an issue with the plot of the TC cells, they do not display any action potentials.

The line that displays the waveforms is:

simConfig.analysis['plotTraces'] = {'include': [('PY',0),('IN',0),('TC',10),('RE',10)], 'timeRange': [0,2000], 'oneFigPer': 'trace', 'overlay': False, 'saveFig': './images/plotTraces.png'}

‘TC’ and ‘RE’ are called with argument 10 instead of 0. Discovered that instead substituting (‘TC’,0) and (‘RE’,0) shows TC cell action potentials. Verified that 0 refers to a specific PY cell index 0.

* 8.9.19 Differences in mechanisms between oc version and netpyne version
With both models executing without issue, my next goal is to implement the mutations and drug effects implemented in the hoc model into netpyne. The first challenge is that the hoc model and netpyne model do not use the same channel descriptions. whilst the hoc model uses a wild-type sodium channel inak2005.mod as well as an inak2005mut.mod to describe mutations, the netpyne port uses a Hodgin-Huxley channel described in HH2.mod. The parameters of these two models are not the same. I will look through the netpyne port RE.tem, TC.tem, mPYr.py, sIN.tem and sPY.tem neuron descriptions to see about implementing the inak2005 channel. 

Based on this I have found running

diff -b -y --width=200

to evaluate the files is a good solution and found the following differences between the hoc model and the netpyne port.

RE.tem
In hoc model, RE.tem does not use hh2, uses inak2005 and itrecustom
TC.tem
In hoc model, TC.tem does not use hh2, uses inak2005
sIN.tem
In hoc model, sIN.tem does not use hh2, uses inak2005 and inak2005mut
sPY.tem
In hoc model, sPY.tem does not use hh2, uses inak2005

I found that the .c and .o objects in the original hoc model were not part of the model and removed them.
* 8.19.19 Getting NetCons out of oc file
** In order for the netpyne port to behave similarly to the original, we are duplicating elements of the original hoc model into the netpyne port. One of these tasks include duplicating the connections (NetCons) between the original and the port. In the original, they are described in fSpikeWave.oc and in the port netParams.py. By using the following lines of code, output information on NetCons from fSPikeWave.oc into a csv file netcon_data.csv for parsing
*** code
//----------------------------------------------------------------------------
//  netcon file
//----------------------------------------------------------------------------

objref ncl
ncl = new List("NetCon")
objref ncfile
netcons = ncl.count()
ncfile = new File()
ncfile.wopen("netcon_data.csv")
for i = 0, netcons-1{
 if (ncl.o(i).weight[0] > 0) {
    ncfile.printf("%s,", ncl.o(i).precell()  )
    ncfile.printf("%s,", ncl.o(i).postcell() )
    ncfile.printf("%s,", ncl.o(i).syn()      )
    ncfile.printf("%d,", ncl.o(i).delay      )
    ncfile.printf("%d\n", ncl.o(i).weight[0]  )
 }
}
ncfile.close()
** For some reason, weights are either 0 or 1 instead of some floating point between 0 and 1, which is unexpected.
* 8.20.19 Parsing NetCons, storing into json file
** Parsing done in python, the csv file was parsed with information stored into a python dictionary dumped into a json file with the following code
*** code
import re
import json

netcons = {}
for line in open('netcon_data.csv'):
   precell, postcell, syn, delay, weight = re.split(r',', line)
   precellStr,  precellId  = re.split(r'[\[\]]', precell )[0:2]
   postcellStr, postcellId = re.split(r'[\[\]]', postcell)[0:2]
   synStr = re.split(r'\[', syn)[0]
   conStr = precellStr+'->'+postcellStr
   if synStr in netcons:
       if conStr in netcons[synStr]:
           netcons[synStr][conStr].append([int(precellId), int(postcellId)])
       else:
           netcons[synStr][conStr] = []
           netcons[synStr][conStr].append([int(precellId), int(postcellId)])
   else:
       netcons[synStr] = {}
       netcons[synStr][conStr] = []
       netcons[synStr][conStr].append([int(precellId), int(postcellId)])

with open('netcons.json', 'w') as fp:
   json.dump(netcons, fp)
**  Chose json as versus pkl can get better visualization of the data structure by opening json with web browser. The pre and post cell IDs for each connection are stored as a list of 2 elements (pre, post), can be accessed after loading json for instance by [‘AMPA_S’][‘sTC->sRE’]. Implemented loading netcons. Because weight was either 0 or 1, filtered out weight with zero and kept weight with one. Will look into this.
* 8.21.19 Importing json file to netpyne port, peculiarity with GABAB (gmax vs. weight)
** Imported json file into netpyne port and set explicit connections in netParams.connParams['PRE->POST'], 'connList'
*** code excerpt from myKnoxRepo/netParams.py
netParams.connParams['RE->RE'] = {
    'preConds': {'popLabel': 'RE'}, 
    'postConds': {'popLabel': 'RE'},
    'weight': RERE*0.2/(N_RE*RE_RE_GABAA_Prob+1),            # (Destexhe, 1998)
    #'weight': 0.2,            # (Destexhe, 1998)
    'delay': netParams.axondelay, 
    'loc': 0.5,
    'sec': 'soma',
    #'threshold': 0,
    'synMech': 'GABAA_S',
    #'synsPerConn': 1,
    #'probability': '1.0 if dist_x <= narrowdiam*xspacing else 0.0'}   
    #'probability': RE_RE_GABAA_Prob}
    'connList': netcons['GABAa_S']['sRE->sRE']}
    #'connList': smallWorldConn(N_RE,N_RE,pThl,RE_RE_GABAA_Prob,selfConn)} 
** Did not change 'weight' setting, since the exported values in csv were not set (were either 1 or 0). While reviewing weights, found that the original oc model had a peculiarity when setting GABAB weights in the procedure assign_synapses(), namely that the gmax value was set rather than the weight
*** code excerpt from Dravet/Fspikewave.oc
    for j=0, TC[i].gababpost.count()-1 {
	TC[i].gababpost.object(j).gmax = $3 / nRETC
	//TC[i].REgabablist.object(j).weight = $3 / nRETC
    }
** in the NetPyNE port, both the gmax and weight is set, commented out the weight and kept gmax set (does weight default to 1?). This is most likely not the correct solution.
* 8.22.19 GABAA weights, peculiarity with IN->IN GABAB weight
** Found issue with weights being either 0 or 1, the procedure to assign weights was included in the initialization code block proc init () that only ran after user input. Put in code in segment to output weights to a debug file. 
** Boundary cases were explained, that cells at the minimum and maximum of the simulation parameters (i.e. TC[0], TC[99]) would synapse differently than other neurons, was speculated that this was the reason for the earlier termination of spindle activity in netpyne port versus original oc model
** gabaapercent was altered to 0 and then 10 to evaluate model, with gabaapercent at 0, netpyne model shows long spindle of activity that lasts for approx 1500 ms and then quiescence, while the original model showed two shorter spindles lasting approx 350 ms then a break for approx 233 ms, then another spindle approx 233 ms. Set gabaapercent to 10 TODO look at GABAB total conductance and IM in PY neurons
** found additional discrepancy regarding weight IN->IN GABAA weight in original model set to 0, TODO compare weights.
** When setting GABAB gmax (conductance) to 0 from initial value found that output voltage traces do not change. Evaluate this.
* 8.23.19 Looking deeper at GABAB effects
** Set GABAB gmax to zero in original model, this shows single long spindle lasting about 700 ms versus 3 shorter spindles, in the netpyne model, we also get one long spindle, though it lasts significantly longer at approx 1500 ms
*** debug output of weights
GABA A RERE: 0.018182
GABA A RETC: 0.000182
GABA B RETC (gmax): 0.000000
GABA B RETC (weight): 1.000000
AMPA   TCRE: 0.018182
AMPA   PYRE: 0.057143
AMPA   PYTC: 0.000476
AMPA   PYPY: 0.054545
GABA A INPY: 0.002727
GABA B INPY (gmax): 0.000000
GABA B INPY (weight): 1.000000
AMPA   TCPY: 0.057143
AMPA   PYIN: 0.018182
** Output current and conductance of GABAB channels in netpyne port, shows that conductance g rapidly approaches and stays at gmax through simulation with no effect on output waveform.
** was suggested that the GABAB channels were not inserted, evaluated this using has_loc() and get_segment(). Found documentation best by googling "neuron yale has_loc"
*** code
ncl = h.List("NetCon")
asy = [x for x in ncl if 'GABAb' in str(x.syn())]
In [5]: asy[0].syn().has_loc()
Out[5]: 1.0
In [6]: asy[0].syn().get_segment()
Out[6]: <netpyne.cell.compartCell.CompartCell object at 0x7f0457c224a8>.soma(0.5)
* 8.25.19 Using oc terminal
*** code
oc>GABAb_S[3000].get_segment().sec.name()
	sPY[85].soma[0] 
oc>sPY[85].gababpost.object(0).g
	0.0018457503 
oc>sPY[85].gababpost.object(0).i
	0.095011927 
oc>GABAb_S[3000].g
	0.0018457503 
oc>GABAb_S[3000].i
	0.095011927 
oc>GABAb_S[0].get_segment().sec.name()
	sTC[4].soma[0] 
oc>sTC[4].gababpost.object(0).g
	0.0029656521 
oc>sTC[4].gababpost.object(0).i
	0.029477722 
oc>GABAb_S[0].g
	0.0029656521 
oc>GABAb_S[0].i
	0.029477722 
** I noticed in the oc model that changing dt changed the activity of the network, in fact, changing dt from 0.1 -> 0.025 caused conductance to behave very similarly to netpyne model

* 8.26.19 Something fishy with GABAB conductance and current
** createSimulateAnalyze runs sim.create(netParams, simConfig), sim.simulate(), sim.analyze()
** need to find out more about sim.net.connectCells()
** need to find out more about neuroml2 format
*** code
objref PYg
PYg = new Vector()
PYg.record(&PY[11].gababpost.object(0).g)
objref PYi
PYi = new Vector()
PYi.record(&PY[11].gababpost.object(0).i)
...
oc>PYg.max()
	0.00096263933 <=== gmax is 0.0027272727
oc>PYi.max()
	0.091968492 
oc>TCg.max()
	0.00035532494 <=== gmax is 0.0036363636
oc>TCi.max()
	0.025714165 
** looked at save.py to see how netpyne saves data, then used to get data on GABAB g and i
*** code
In [1]: traces = sim.cfg.recordTraces

In [2]: traces.keys()
Out[2]: dict_keys(['V_soma', 'i_GABAB1', 'g_GABAB1', 'i_GABAB2', 'g_GABAB2'])

In [3]: sim.allSimData['i_GABAB1'].keys()
Out[3]: dict_keys(['cell_11'])

In [4]: sim.allSimData['i_GABAB2'].keys()
Out[4]: dict_keys(['cell_311'])

In [11]: max(sim.allSimData['g_GABAB2']['cell_311'])   <=== TC cells
Out[11]: 0.003635775561015554

In [12]: max(sim.allSimData['i_GABAB2']['cell_311'])
Out[12]: 0.11247954343543566

In [13]: max(sim.allSimData['g_GABAB1']['cell_11'])    <=== PY cells
Out[13]: 0.0027271393472713284

In [14]: max(sim.allSimData['i_GABAB1']['cell_11'])
Out[14]: 0.3278113855100482

In [15]: len(sim.allSimData['i_GABAB1']['cell_11'])    
Out[15]: 20000                                         <=== # of simulation points
** comparing maximal g and i between models, we see that the netpyne model has much greater conductance and current but has no noticable impact on voltage waveforms vs. the hoc model.
          hoc             netpyne
PY g =>   0.00096263933   0.0027271393472713284
PY i =>   0.091968492     0.3278113855100482

TC g =>   0.00035532494   0.003635775561015554
TC i =>   0.025714165     0.11247954343543566
* 8.27.19 Working on single GABAB receptor
** Unsure if comparing current and conductance across all GABAB synapses for that cell in netpyne
the record statement in the hoc model is recording from a single synapse GABAb, while the netpyne version is recording 'i_GABAB' and 'g_GABAB', this may be the current and conductance through all GABAb synapses at that cell.
** Getting values from connlist in python, seeing which GABAb synapses are connected to postcell 11
*** code
>>> import json
>>> with open('netcons.json', 'r') as fp:
>>> connlist = netcons['GABAb_S']['sRE->sTC']
>>> len(connlist)
1100
>>> postcell = [x for x in connlist if x[1] == 11]
>>> postCell
[[6, 11], [7, 11], [8, 11], [9, 11], [10, 11], [11, 11], [12, 11], [13, 11], [14, 11], [15, 11], [16, 11]]
>>> len(x)
11
** Started working on isolating single and several GABA b synapse in oc and netpyne to see how they act
* 8.28.19 Large discrepancy revealed with GABAb synapses using h.List("GABAb_S")
** Spoke with Dr. Lytton, reverified GABAb weights, however new issue discovered when checking network with List() command.
** There are only 200 GABAb synaptic point processes in netpyne version vs original.
*** code
**** netpyne implementation
In [13]: AMPAcon = h.List("AMPA_S")

In [14]: len(AMPAcon)      <===
Out[14]: 500               <===

In [15]: GABAAcon = h.List("GABAa_S")

In [16]: len(GABAAcon)
Out[16]: 500

In [17]: GABABcon = h.List("GABAb_S")

In [18]: len(GABABcon)     <===
Out[18]: 200               <===

**** original hoc implementation
oc>objref AMPA
oc>AMPA = new List("AMPA_S")
oc>AMPA.count()            
	600                      <===
oc>objref GABAA
oc>GABAA = new List("GABAa_S")
oc>GABAA.count()
	500 
oc>objref GABAB
oc>GABAB = new List("GABAb_S")
oc>GABAB.count()
	3300                     <===
oc>

** All GABAb synapses seem to have been handled as single synapse on postsynaptic neuron with multiple presynaptic inputs, no 1:1 ratio of netcons to GABAb which is needed for model to run
** Per Dr. Lytton, will have to set up GABAB connections outside of netpyne and worry about integrating it later.
** Met with Dr. Qiang Wang (new researcher), showed him the linux system in lab, he will set up Python, Neuron, Netpyne, GitHub on his own system, currently using Windows machine, he might set up Ubuntu 18.04 or purchase Macbook

* 8.29.19 Creating GABAb synapses outside of netpyne
** Working on establishing GABAB connections in network created by netpyne
*** discussion
cells are found in 
sim.net.cells[<<cell_ID>>]
additionally, can access cell IDs through
sim.net.pops['<<ID>>'].cellGids
This indicates following populations of cells:
PYcells = sim.net.cells[  0:100]
INcells = sim.net.cells[100:300]
TCcells = sim.net.cells[300:400]
REcells = sim.net.cells[400:500]
*** oc code that needs to be implemented
for i=0,nthalamiccells-1 {
   for j=i-diamRETC,i+diamRETC {
	jbound = j
	if (jbound < 0) jbound = abs(j) - 1
	if (jbound > nthalamiccells-1) jbound = 2 * nthalamiccells - jbound - 1

	// presynaptic is RE[i], postsynaptic is TC[j]
	// ***Note: GABAb synapses are implemented as a list of individual synapses (in contrast to other synapse types), and so are created here
	gababsyn = new GABAb_S()
 	TC[jbound].soma gababsyn.loc(0.5)
	TC[jbound].gababpost.append(gababsyn)
	RE[i].soma TC[jbound].REgabablist.append(new NetCon(&v(0.5), gababsyn, 0, axondelay, 1))	
   }
}
** asked about line: TC[jbound].soma gababsyn.loc(0.5)
was told operates as loc command
gababsyn.loc(0.5, sec = TC[jbound].soma)
RE[i].soma TC[jbound].REgabablist.append(new NetCon(&v(0.5), gababsyn, 0, axondelay, 1))
* 8.30.19 Porting oc code to neuron+python
*** code for the new netconnections
(pops, cells, conns, rxd, stims, simData) = sim.create(netParams.netParams, cfg.simConfig, output=True)

PYcells = sim.net.cells[  0:100]
INcells = sim.net.cells[100:300]
TCcells = sim.net.cells[300:400]
REcells = sim.net.cells[400:500]

PYsomas = [ x.secs['soma']['hObj'] for x in PYcells ]
INsomas = [ x.secs['soma']['hObj'] for x in INcells ]
TCsomas = [ x.secs['soma']['hObj'] for x in TCcells ]
REsomas = [ x.secs['soma']['hObj'] for x in REcells ]

#RETCgababsyns = []
for i in range(100):                               <=== for i=0,nthalamiccells-1 {        <=== for i=0,99
  for j in range(i-5, i+5+1):                      <===   for j=i-diamRETC,i+diamRETC {   <=== for j=i-5,i+5 so UL should be i+5+1 for range
    jbound = j
    if (jbound < 0):
        jbound = abs(j) - 1
    if (jbound > 99): 
        jbound = 2 * 100 - jbound - 1
    ## presynaptic is RE[i], postsynaptic is TC[j]
    ## ***Note: GABAb synapses are implemented as a list of individual synapses (in contrast to other synapse types), and so are created here
    gababsyn = h.GABAb_S()                                                 #gababsyn = new GABAb_S()
    gababsyn.loc(0.5, sec = TCsomas[jbound])                               #TC[jbound].soma gababsyn.loc(0.5)
                                                                           #TC[jbound].gababpost.append(gababsyn)
    h.NetCon( REsomas[i](0.5)._ref_v, gababsyn, 0, 2, 1, sec = REsomas[i]) #RE[i].soma TC[jbound].REgabablist.append(new NetCon(&v(0.5), gababsyn, 0, axondelay, 1))
    	
#INPYgababsyns = []
for i in range(100):
  for j in range(i-5, i+5+1):
    jbound = j
    if (jbound < 0):
        jbound = abs(j) - 1
    if (jbound > 99):
        jbound = 2 * 100 - jbound - 1
    ## presynaptic is IN[i], postsynaptic is PY[j]
    ## ***Note: GABAb synapses are implemented as a list of individual synapses (in contrast to other synapse types), and so are created here
    gababsyn = h.GABAb_S()                                                         #gababsyn = new GABAb_S()
    gababsyn.loc(0.5, sec = PYsomas[jbound])                                       #PY[jbound].soma gababsyn.loc(0.5)
                                                                                   #PY[jbound].gababpost.append(gababsyn) 
    h.NetCon( INsomas[i](0.5)._ref_v, gababsyn, 0, 2, 1, sec = INsomas[i])         #IN[i].soma PY[jbound].INgabablist.append(new NetCon(&v(0.5), gababsyn, 0, axondelay, 1))

    #add for new set of IN cells
    gababsyn = h.GABAb_S()
    gababsyn.loc(0.5, sec = PYsomas[jbound])                                       #PY[jbound].soma gababsyn.loc(0.5)
	                                                                               #PY[jbound].gababpost.append(gababsyn) 
    h.NetCon( INsomas[i+100](0.5)._ref_v, gababsyn, 0, 2, 1, sec = INsomas[i+100]) #IN[i+100].soma PY[jbound].INgabablist.append(new NetCon(&v(0.5), gababsyn, 0, axondelay, 1))
** However, issue with number of GABAb_S() being created and saved in this code, as 
In [1]: len(h.List("GABAb_S"))
Out[1]: 1
In [2]: len(h.List("NetCon"))
Out[2]: 15088
** seems need to save gababsyn and netcon somewhere, so created lists and "saved" them there (appended them), this resolved the "disappearing" synapses and netcons.
* 9.2.19 Verifying GABAB parameters
** Verified GABAB parameters, seems like default values are same. 
	K1_GABAb_S	= 0.09		//	(/ms mM) forward binding to receptor
	K2_GABAb_S	= 0.0012	//	(/ms)	backward (unbinding)of receptor
	K3_GABAb_S	= 0.18 		//	(/ms)	rate of G-protein production
	K4_GABAb_S	= 0.034		//	(/ms)	rate of G-protein decay  -  larger number = slower decay?
	KD_GABAb_S	= 100		//	dissociation constant of K+ channel
	n_GABAb_S	= 4		//	nb of binding sites of G-protein on K+
	Erev_GABAb_S	= -95		//	(mV)	reversal potential (E_K)
	Cmax_GABAb_S = 0.5		// short pulses
	Cdur_GABAb_S = 0.3

In [8]: RETCgababsyns[0].K1 ====> Out[8]: 0.09
In [9]: RETCgababsyns[0].K2 ====> Out[9]: 0.0012
In [10]: RETCgababsyns[0].K3 ===> Out[10]: 0.18
In [11]: RETCgababsyns[0].K4 ===> Out[11]: 0.034
In [12]: RETCgababsyns[0].KD ===> Out[12]: 100.0
In [13]: RETCgababsyns[0].n ====> Out[13]: 4.0
In [14]: RETCgababsyns[0].Erev => Out[14]: -95.0
In [15]: RETCgababsyns[0].Cmax => Out[15]: 0.5
In [16]: RETCgababsyns[0].Cdur => Out[16]: 0.3
** Assigned gmax for GABAB, turns out gabab needs to be assigned to a point with loc or else gmax cannot be assigned:
In [17]: gabab = h.GABAb_S()

In [18]: gabab.gmax
NEURON: point process not located in a section
...
** After recreating the GABAB synapses outside of netpyne, network still does not behave as anticipated. 
* 9.3.19 PLotting GABAB current and conductance using neuron+python
** Will look at AMPA synapses next, there are 100 synapses missing from netpyne model.
** Plotting GABAB current and conductance, using Vector class:
*** In original hoc
  objref PYg
  PYg = new Vector()
  PYg.record(&PY[11].gababpost.object(0).g)

*** so now in python:

In [19]: PYg.record(INPYgababsyns[200].g)
bad stack access: expecting (double *); really (double)
NEURON: interpreter stack type error
 near line 0
 ^
        Vector[7].record(0)
oc_restore_code tobj_count=2 should be 1
---------------------------------------------------------------------------
RuntimeError                              Traceback (most recent call last)
<ipython-input-19-8a255be11a32> in <module>()
----> 1 PYg.record(INPYgababsyns[200].g)

RuntimeError: hoc error

In [20]: PYg.record(INPYgababsyns[200]._ref_g)
Out[20]: Vector[7] 

Details: NEURON pointers in python are handled using the _ref_ syntax. e.g., soma(0.5)._ref_v
** made synapses into double array to clean references
** TC neurons depolarize first prior to 250 ms, run simulation to 250 ms and then evaluate current.
** Or, add Iclamp stims to TC to force earlier activity?
* 9.4.19 Finding the missing AMPA receptors
** had to debug code, turns out behavior of lists and append not as I expected:
*** code
In [26]: array = [ [ ] ] * 5

In [27]: array
Out[27]: [[], [], [], [], []]

In [28]: array[0].append(0)

In [29]: array[1].append(1)

In [30]: array[2].append(2)

In [31]: array
Out[31]: [[0, 1, 2], [0, 1, 2], [0, 1, 2], [0, 1, 2], [0, 1, 2]]

Rather than 
[ [0] , [1] , [2] , [ ] , [ ] ]
Or append() appends to end of all lists in array

Solution:
In [37]: array = [ [ ] for y in range(5) ]

In [38]: array
Out[38]: [[], [], [], [], []]

In [39]: array[0].append(1)

In [40]: array
Out[40]: [[1], [], [], [], []]

In [41]: array[2].append(1)

In [42]: array
Out[42]: [[1], [], [1], [], []]

In [43]: array[2].append(3)

In [44]: array
Out[44]: [[1], [], [1, 3], [], []]

** see 8.28.19, there are 600 AMPA synaptic point processes defined in original oc code and only 500 AMPA synaptic point processes defined in netpyne implementation
** suspect culprit to be related to pyramidal neurons, where two AMPA point processes should be defined  -- ampapostPY and ampapostTC, that is where PY->PY and TC->PY connections are concerned
** Dr. Knox and Dr. Lytton pointed out that the ampapostPY and ampapostTC can be consolidated into single AMPA synapse as long as NetCons are weighted differently.
** TODO consolidate AMPA synapses to single point
* 9.5.19 What depolarizes first, Netpyne first AP occurs earlier, why?
** In original model, TC raster catches action potential at 236-237 ms
***
oc>TCVtrace[99].x[2362]
	-13.701763 
oc>TCVtrace[99].x[2363] <===
	11.407642             <===
oc>TCVtrace[99].x[2364]
	-39.683937 

** All TC should depolarize at the same time given that there is no randomization
** However in netpyne model, depolarization happens more than 10 ms earlier, prior to 225 ms 
** Use h.psection to evaluate:
h.psection(sec=h.sTC[0].soma[0]) in original model
h.psection(sec=TCsomas[0])       in netpyne model
** h.psection shows more limited data from the oc model, TODO Dr. Lytton wants to expand the definition of h.psection.
** can be found in neuron repo at /neuron/nrn/share/lib/python/neuron/psection.py
** Also notable comments from Dr. Knox--
"it looks like the inhibitory cells are lazy in the new version..."
"yes, in the old one, removing that randomization makes everything weirdly synchronized" -- so randomization of TC cells is important but will add later.
* 9.9.19 Looking through h.psection
** Lazy IN cells, parameters are the same, look through netcons.
** 2200 netcons from sPY->sIN, 200 netcons from sIN->sIN
** check weight of the netcons --
** Issue with weight,
In [10]: ncl = h.List("NetCon")
In [15]: postcellIN = [x for x in ncl if x.postcell().tags['cellType'] == 'IN']
In [17]: PYIN = [x for x in postcellIN if x.precell().tags['cellType'] == 'PY']
In [30]: PYIN[0].weight[0]
Out[30]: 0.009523809523809525 <===

GABA A RERE: 0.018182
GABA A RETC: 0.000182
GABA B RETC (gmax): 0.000000
GABA B RETC (weight): 1.000000
AMPA   TCRE: 0.018182
AMPA   PYRE: 0.057143
AMPA   PYTC: 0.000476
AMPA   PYPY: 0.054545
GABA A INPY: 0.002727
GABA B INPY (gmax): 0.000000
GABA B INPY (weight): 1.000000
AMPA   TCPY: 0.057143
AMPA   PYIN: 0.018182 <===

** Adjusting PYIN weight did not solve the issue of inactive IN neurons, but replacing all weights did.
** PYIN = .2 / 11 versus .2 / 21
** Look into earlier TC depolarization
** Look into lazy IN cells
** Look into h.psection
* 9.12.19 Looking at netcons
** CVode.netconlist() to verify netcons
** Number of netcons for synapse type --
AMPA
TC->RE = 1100
PY->PY = 1100
PY->IN = 2200
PY->RE = 2100
PY->TC = 2100
TC->PY = 2100
10700 netcons vs. 10594 netcons - 106 missing netcons
GABAA
RE->RE = 1100
RE->TC = 1100
IN->PY = 2200
IN->IN = 200
4600 netcons vs. 4494 netcons   - 106 missing netcons
GABAB
RE->TC = 1100
IN->PY = 2200
3300 netcons vs. 3300 netcons
18600 netcons in total

18388 netcons in netpyne
15088 netcons of AMPA and GABAA type
** code
cvode = h.CVode()
cvode.netconlist("","","")

In [9]: len(cvode.netconlist("","","AMPA"))
Out[9]: 10594

In [11]: len(cvode.netconlist("","","GABAa"))
Out[11]: 4494

* 9.16.19 Replicating divergence in oc code, chasing missing netcons
** oc code has elements of divergence
for (i=0;i<=ncorticalcells-1;i+=divergence) {
   for j=i/divergence-diamPYRE,i/divergence+diamPYRE {
	jbound = j
	if (jbound < 0) jbound = abs(j) - 1
	if (jbound > nthalamiccells-1) jbound = 2 * nthalamiccells - jbound - 1

	// presynaptic is PY[i], postsynaptic is RE[j] 
	PY[i+divergence/2].soma RE[jbound].PYlist.append(new NetCon(&v(0.5), RE[jbound].ampapost, 0, axondelay, 1))	
   }
}
** how oc code handles indexing with non-integer values
oc>for (i = 0.5; i < 5.5; i+=2) { print i}
0.5 
2.5 
4.5 
oc>PY[2.5] <-- floors when accessing array
	sPY[2] 
oc>for i = 0.5, 5.5 { print i}
0.5 
1.5 
2.5 
3.5 
4.5 
5.5 
** implemented oc code to NetPyNE
** using cvode on original oc
In [1]: cvode = h.CVode()

In [18]: len(cvode.netconlist("",h.PY[0],"AMPA"))
Out[18]: 32

In [19]: len(cvode.netconlist("",h.PY[0],"GABAa"))
Out[19]: 22

In [20]: len(cvode.netconlist("",h.PY[0],"GABAb"))
Out[20]: 22

In [21]: len(cvode.netconlist("",h.PY[0],""))
Out[21]: 76

In [22]: len(cvode.netconlist("","PY",""))
Out[22]: 7600

In [23]: len(cvode.netconlist("","PY","GABAb"))
Out[23]: 2200

In [24]: ncl = cvode.netconlist("",h.PY[0],"AMPA")

In [25]: ncl[0]
Out[25]: NetCon[4904]

** However, cvode and netpyne do not work well together
** Spoke to Salva and Bill, netconlist looks like dead end will go to h.List()

** implemented netcon dictionary in netpyne code to get better look at netcons, found that missing netcons in AMPA_S PYPY connections and GABAA RERE connections
In [2]: len(netcons['AMPA_S']['PYPY']) <--- missing 106 netcons
Out[2]: 994    

In [4]: len(netcons['AMPA_S']['PYIN'])
Out[4]: 2200

In [5]: len(netcons['AMPA_S']['TCRE'])
Out[5]: 1100

In [6]: len(netcons['AMPA_S']['PYTC'])
Out[6]: 2100

In [7]: len(netcons['AMPA_S']['PYRE'])
Out[7]: 2100

In [8]: len(netcons['AMPA_S']['TCPY'])
Out[8]: 2100

In [16]: len(netcons['GABAa_S']['ININ'])
Out[16]: 200

In [17]: len(netcons['GABAa_S']['INPY'])
Out[17]: 2200

In [18]: len(netcons['GABAa_S']['RETC'])
Out[18]: 1100

In [19]: len(netcons['GABAa_S']['RERE']) <--- missing 106 netcons
Out[19]: 994
----------------------------------------------------------------------------------
In [3]: sPY = netParams.netcons['AMPA_S']['sPYsPY'] <--- connlist used for netcons

In [4]: PY = ncd['AMPA_S']['PYPY']                  <--- netpyne created netcons

In [5]: PY[0:10]
Out[5]: 
[[0, 4],
 [0, 3],
 [0, 2],
 [0, 1],
 [0, 1],
 [0, 2],
 [0, 3],
 [0, 4],
 [0, 5],
 [1, 3]]

In [6]: sPY[0:10]
Out[6]: 
[[0, 4],
 [0, 3],
 [0, 2],
 [0, 1],
 [0, 0],
 [0, 0],
 [0, 1],
 [0, 2],
 [0, 3],
 [0, 4]]

In [11]: sPYselfconn = [x for x in sPY if x[0] == x[1]]

In [12]: len(sPYselfconn)
Out[12]: 106

In [13]: PYselfconn = [x for x in PY if x[0] == x[1]]

In [14]: len(PYselfconn)
Out[14]: 0

In [15]: sPYselfconn[0:10]
Out[15]: 
[[0, 0],
 [0, 0],
 [1, 1],
 [1, 1],
 [2, 2],
 [2, 2],
 [3, 3],
 [4, 4],
 [5, 5],
 [6, 6]]
** what is causing the discrepancy in netcons <--->
netParams.connParams['PY->PY_AMPA'] = {
    'preConds': {'popLabel': 'PY'}, 
    'postConds': {'popLabel': 'PY'},
    'weight': 0.054545,        # PYPY*0.6/(N_PY*PY_PY_AMPA_Prob+1),            # (Destexhe, 1998)
    'sec': 'soma',
    'delay': netParams.axondelay, 
    'loc': 0.5,
    'synMech': 'AMPA_S',
    'connList': [ [0,0] for x in range(1100) ] + [ [0,1] ] }
                             ^                       ^
              NONE of these netcons are created  this netcon is created

In [3]: PY = ncd['AMPA_S']['PYPY']

In [4]: PY
Out[4]: [[0, 1]] <--- only netcon that is created

* 9.17.19 Chasing earlier depolarization part 1
** netpyne model depolarizes faster than oc model, overlay voltages shows that after 1st dt, netpyne model has greater voltage, Bill points out likely parameter issue.
** revised weight in code to exactly match Fspikewave.oc, may have been issue between: 0.018182 vs 0.2/11
** simConfig.allowSelfConns = True should allow self conns but doesn't seem to

* 9.18.19 Chasing earlier depolarization part 2
** stripped out parameter declarations for TC cells, drug and wild type mutations, with them stripped out, the oc model now moves to firing earlier
** TC voltages now identical, and rasters similar
** commented in TC parameters and got change in voltage.

In [8]: TCV[2000]
Out[8]: -77.63921453237232

In [1]: TCV[2000]
Out[1]: -79.14505665452351

** there is a difference in these two lines

for i=0,nthalamiccells-1 { 
  TC[i].soma.ghbar_iar = 17.5 * 10^-6 //rgh.repick() * 10^-6 //   
  TC[i].kl.gmax = 40 * 10^-4   //rk1.repick() * 10^-4        //        
  //print "TC(",i,") gh:",TC[i].soma.ghbar_iar," gmax:",TC[i].kl.gmax
}

-----vs NetPyne-----
cellRule = netParams.importCellParams(label='TCrule', conds={'cellType': 'TC', 'cellModel': 'HH_TC'}, fileName='TC.tem', cellName='sTC')

cellRule['secs']['soma']['vinit']=v_init
cellRule['secs']['soma']['ghbar_iar']=17.5e-6
cellRule['secs']['soma']['pointps']['kleak_0']['gmax']=40e-4
netParams.cellParams['TCrule'] = cellRule



In [21]: cellRule = netParams.importCellParams(label='TCrule', conds={'cellType': 'TC', 'cellModel': 'HH_TC'}, fileName='TC.tem', cellName='sTC')
 
<< sTC: passive, Kleak, INa, IK, IT, Ih-CAM and Ca++ decay inserted >>
 

In [22]: cellRule['secs']['soma']
Out[22]: {geom: {L: 96.0, nseg: 1, diam: 96.0, Ra: 100.0, cm: 1.0}, topol: {}, mechs: {cad: {depth: 1.0, taur: 5.0, cainf: 0.00024, kt: 0.0, kd: 0.0}, iar: {ghbar: 2e-05, cac: 0.002, k2: 0.0004, Pc: 0.01, k4: 0.001, nca: 4.0, nexp: 1.0, ginc: 2.0, taum: 20.0, shift: 0.0}, inak2005: {gnatbar: 0.15, gkfbar: 0.06, gnablock: 1.0, mvhalf: 27.4, mk: 5.4043, hvhalf: 41.9, hk: 6.7, svhalf: 46.0, sk: 6.6, hshift: 0.0, sshift: 0.0, mtaubase: 0.15, htaubase: 23.12, htauvhalf: 77.58, htauk: 43.92, staubase: 140400.0, stauvhalf: 71.3, stauk: 30.9}, it: {gcabar: 0.002, shift: 2.0, taubase: 30.8}, pas: {g: 1e-05, e: -70.0}}, ions: {ca: {e: 120.0, i: 0.00024, o: 2.0}, h: {e: -40.0, i: 1.0, o: 1.0}, kf: {e: -100.0, i: 1.0, o: 1.0}, nat: {e: 50.0, i: 1.0, o: 1.0}}, pointps: {kleak_0: {mod: 'kleak', loc: 0.5, gmax: 0.004}}, _repr_mimebundle_: {}}

In [26]: cellRule['secs']['soma']['mechs']['iar']['ghbar']     <=== proper way to get to ghbar
Out[26]: 2e-05

In [27]: cellRule['secs']['soma']['ghbar_iar']                 <=== not proper way to get to ghbar
Out[27]: {_repr_mimebundle_: {}}

** correctly set ghbar, now TC cells fire properly
** looking for next issue
** taking a look at spike times
*** PY[50] first 5 are the same 6th is different
In [16]: pyt = [spkt[x] for x in range(len(spkt)) if spkid[x] == 50]

In [17]: pyt[0:5]
Out[17]: 
[240.8000000001205,
 242.2000000001208,
 249.10000000012238,
 249.90000000012256,
 250.80000000012276]

In [20]: pyt[6]
Out[20]: 255.90000000012392


** ### Summary of what's changed since picking up port code ###
GABAb synapses not implemented properly -- 200 GABAb instead of 3300 GABAb
weights not correctly set and weight vs gmax issue
TC randomization
autapses were ignored

* 9.19.19 what's the next difference
** comparing voltages to look for differences
** used pickle to dump voltage data and raster data to a separate directory with comparison 

oc = {}
pyv = {}
inv = {}
tcv = {}
rev = {}

pyv['bound'] = [x for x in h.PYVtrace[0] ]
pyv['mid']   = [x for x in h.PYVtrace[49]]

inv['bound'] = [x for x in h.INVtrace[0] ]
inv['mid']   = [x for x in h.INVtrace[49]]

tcv['bound'] = [x for x in h.TCVtrace[0] ]
tcv['mid']   = [x for x in h.TCVtrace[49]]

rev['bound'] = [x for x in h.REVtrace[0] ]
rev['mid']   = [x for x in h.REVtrace[49]]

oc['pyv'] = pyv
oc['inv'] = inv
oc['tcv'] = tcv
oc['rev'] = rev

oc['spkt'] = spkt
oc['spkid'] = spkid

with open('/home/jchen/CompNeuro/shared/oc.pkl', 'wb') as fp:
    pickle.dump(oc, fp)

find differences in voltage:

In [14]: delta = [ [x , oc['pyv']['bound'][x] - np['pyv']['bound'][x] ] for x in range(2900) ]

In [15]: delta = [ [x, y] for [x, y] in delta if y != 0 ]

In [16]: delta[0]
Out[16]: [2430, 2.1316282072803006e-14]

===pyv===
bound: [2430, 2.1316282072803006e-14] <=== earliest discrepancy in voltages occurs at 243
mid: [2430, 7.105427357601002e-15]
===inv===
bound: [2575, -0.0047958884603289675]
mid: [2591, 0.001413555973158509]
===tcv===
bound: [2575, -6.335476354735192e-05]
mid: [2591, -0.0005352020553104353]
===rev===
bound: [2575, -0.007280047926386146]
mid: [2591, -0.010982179722425656]

So likely suspects...

['AMPA_S']['PYPY']
['AMPA_S']['TCPY']
['GABAa_S']['INPY']

Removed a lot of connections, remaining connections are

AMPA TC->RE
GABAa RE->RE
GABAa RE->TC

AMPA TC->PY

So 

TC starts

TC->RE<->RE->TC

TC->PY

forced TC->PY weights to be the same and got same results

In [2]: ncl = h.List('NetCon')

In [7]: PYPOST = [x for x in ncl if x.postcell().tags['cellType'] == 'PY']

In [8]: TCPY = [x for x in PYPOST if x.precell().tags['cellType'] == 'TC']

In [9]: TCPY[0].weight[0]
Out[9]: 0.05

* 9.20.19 making rasters similar, looking for issues, found AMPA PY->PY culprit, netcons to single PP versus netcons to separate PP
** reorganized synapse code in netParams to match Fspikewave
** rasters look different when voltages are the same, looked like netpyne fired more frequently, changed these lines in oc
PY[i].soma tobj = new NetCon(&v(0.5), nil) 
to
PY[i].soma tobj = new NetCon(&v(0.5), nil, 0, 1, 0)
** seeing what else isn't working
AMPA TC->RE
GABAa RE->RE
GABAa RE->TC
AMPA TC->PY
seems to be working

So 

TC starts
TC->RE<->RE->TC
TC->PY

NOTE -- 230->260 is a good window to evaluate

added in PY->PY

AMPA TC->RE    -> working
GABAa RE->RE   -> working
GABAa RE->TC   -> working
AMPA TC->PY    -> working
AMPA PY->PY    -> ?

result:
===pyv===
bound: [2430, 2.1316282072803006e-14]
mid: [2430, 7.105427357601002e-15]
===inv===
===tcv===
===rev===

so PY->PY not implemented correctly in netpyne version

weights are the same and postsynapse conns are the same

*** oc analysis
In [1]: cvode = h.CVode()

In [2]: PYPY0 = cvode.netconlist("PY", h.sPY[0], "AMPA")

In [4]: PYPY50 = cvode.netconlist("PY", h.sPY[50], "AMPA")

In [7]: [x.precell() for x in PYPY0]
Out[7]: [sPY[1], sPY[1], sPY[2], sPY[2], sPY[3], sPY[3], sPY[4], sPY[4], sPY[5]]

In [8]: [x.precell() for x in PYPY50]
Out[8]: 
[sPY[45],
 sPY[46],
 sPY[47],
 sPY[48],
 sPY[49],
 sPY[51],
 sPY[52],
 sPY[53],
 sPY[54],
 sPY[55]]

In [9]: PYPY50[0].weight[0]
Out[9]: 0.05454545454545454

*** netpyne analysis

In [7]: [x for x in ncd['AMPA_S']['PYPY'] if x[2] == 0]
Out[7]: [[1, 0], [1, 0], [2, 0], [2, 0], [3, 0], [3, 0], [4, 0], [4, 0], [5, 0]]

In [8]: [x for x in ncd['AMPA_S']['PYPY'] if x[2] == 50]
Out[8]: 
[[45, 50],
 [46, 50],
 [47, 50],
 [48, 50],
 [49, 50],
 [51, 50],
 [52, 50],
 [53, 50],
 [54, 50],
 [55, 50]]

AMPA TC->RE    -> working
GABAa RE->RE   -> working
GABAa RE->TC   -> working
AMPA TC->PY    -> working
AMPA PY->PY    -> broken
AMPA PY->IN    -> working
GABAa IN->PY   -> working
GABAa IN->IN   -> working
AMPA PY->RE    -> working
AMPA PY->TC    -> working
AMPA TC->PY    -> working

** AMPA PY->PY fixed when given its own separate point process.
see discussion about ampapostPY and ampapostTC earlier, issue was that these netcons were sharing same point process
differences resolved when AMPA PY->PY given its own PP to connect to.

* 9.23.19 implementing RETC GABAB
** RETC GABAB implementation
(python3) jchen@jchen-ThinkPad-11e-3rd-Gen:~/CompNeuro/shared$ ipython -i compare.py
Python 3.7.3 (default, Mar 27 2019, 22:11:17) 
Type 'copyright', 'credits' or 'license' for more information
IPython 6.5.0 -- An enhanced Interactive Python. Type '?' for help.
===pyv===
===inv===
===tcv===
bound: [2459, 7.105427357601002e-15] <=== earliest difference caused by implementing RETC gabab
mid: [2459, 7.105427357601002e-15]
===rev===

** isolate change to one GABAb

oc code
gababsyn = new GABAb_S()
TC[0].soma gababsyn.loc(0.5)
TC[0].gababpost.append(gababsyn)
RE[0].soma TC[0].REgabablist.append(new NetCon(&v(0.5), gababsyn, 0, axondelay, 1))

np code
gababsyn = h.GABAb_S()
gababsyn.loc(0.5, sec = TCsomas[0])
gababsyn.gmax = 0.04 / 11
ncon = h.NetCon( REsomas[0](0.5)._ref_v, gababsyn, 0, 2, 1, sec = REsomas[0])

(python3) jchen@jchen-ThinkPad-11e-3rd-Gen:~/CompNeuro/shared$ ipython -i compare.py
Python 3.7.3 (default, Mar 27 2019, 22:11:17) 
Type 'copyright', 'credits' or 'license' for more information
IPython 6.5.0 -- An enhanced Interactive Python. Type '?' for help.
===pyv===
===inv===
===tcv===
bound: [2464, 7.105427357601002e-15] <=== difference due to one netcon
===rev===

In [7]: h.psection(TCsomas[0])
compartCell_PY_HH_PY_0.soma { nseg=1  L=96  Ra=100
	/*location 0 attached to cell 0*/
	/* First segment only */
	insert morphology { diam=96}
	insert capacitance { cm=1}
	insert im { gkbar_im=3e-05 taumax_im=1000}
	insert k_ion { ek=-77}
	insert inak2005 { gnatbar_inak2005=0.3 gkfbar_inak2005=0.03 gnablock_inak2005=1 mvhalf_inak2005=27.4 mk_inak2005=5.4043 hvhalf_inak2005=41.9 hk_inak2005=6.7 svhalf_inak2005=46 sk_inak2005=6.6 hshift_inak2005=0 sshift_inak2005=0 mtaubase_inak2005=0.15 htaubase_inak2005=23.12 htauvhalf_inak2005=77.58 htauk_inak2005=43.92 staubase_inak2005=140400 stauvhalf_inak2005=71.3 stauk_inak2005=30.9}
	insert nat_ion { enat=50}
	insert kf_ion { ekf=-100}
	insert pas { g_pas=0.0001 e_pas=-70}
	insert AMPA_S { Cmax=0.5 Cdur=0.3 Alpha=0.94 Beta=0.18 Erev=0 gmax=0}
	insert GABAa_S { Cmax=0.5 Cdur=0.3 Alpha=20 Beta=0.162 Erev=-85 gmax=0}
	insert AMPA_S { Cmax=0.5 Cdur=0.3 Alpha=0.94 Beta=0.18 Erev=0 gmax=0}
}
--> where is GABAb?
** found issue was gmax wasn't set properly.
** now everything running same, will add in channel mutations and drug types
** channel mutations and drug types added without issue.

** new task to implement GABAb connections in netpyne.
Best workaround so far:
declare 11 or 22 GABAb synmechs to and create new appropriate connLists  

*** conversation on slack
billl 1:54 PM
@jchen.6727 @salvadord -- salva, offhand any method for handling synmechs that need to be 1:1 with netcons rather and don't allow multiple netcons to project in to one?
salvadord:speech_balloon: 1:55 PM
hmm that’s kind of the default in netpyne, unless targeting same segment specifically
so netpyne will create try to spread conns across segments, and creae separate syns for each
jchen.6727 1:58 PM
they are targetting same segment, 1 segment will have 11 or 22 GABAb synapse point processes
billl 1:58 PM
so one hack would be to make multiple segments just to make this work
though would be nice if was an option -- let's take a look at code and see how hard
salvadord:speech_balloon: 1:59 PM
y all implemented assuming won’t have >1 synMech of same type at same segment
so could be tricky to adapt code
a trick could be to create different synMechs (different labels) but with same params
or as you say diff segments
billl 2:01 PM
ok so let's start with hack -- either diff labels or diff segs
can do in a loop by generating labels of the form gabab%d
lab meeting starting
now
jchen.6727 3:43 PM
Sorry still some questions,
so in terms of making different labels  work,
once we generate 11 or 22 synMechs, we would then have to create 11 or 22 connectivity rules corresponding to the number of synMechs, right?
Otherwise I think I have a clear picture of how I can make the diff labels hack work, though the code at the end won't look tidy
in terms of seg I can add segments by changing the nseg value right? but I can't find a place in the connectivity rules where I can specify a target segment,
unless segment == section
jchen.6727 3:53 PM
in which case the resulting code at the end would be cleaner because it looks like the sec argument would create the 11 or 22 synaptic PP for me
Untitled 
sec (optional) - Name of target section on the postsynaptic neuron (e.g. 'soma').
If omitted, defaults to ‘soma’ if exists, otherwise to first section in the cell sections list.
If synsPerConn > 1, and a list of sections or sectionList is specified, synapses will be distributed uniformly along the specified section(s), taking into account the length of each section.



salvadord:speech_balloon: 3:53 PM
you can list multiple synMechs in the same conn rule
re: different segments they should be distributed uniformly across segments by default
jchen.6727 3:55 PM
the synMech argument? I think I might have misinterpreted something there, I thought that would create multiple types of synaptic PP per one connection
billl 3:59 PM
better idea not to create multiple segs since that will slow down whole sim unnecessarily
multiple types -- in this case all are of same type but just using this as a hack to get multiple in
jchen.6727 3:59 PM
multiple segs it would also mean I couldn't get exact same output voltages as oc model anymore either right?
billl 4:00 PM
this is a pretty common situation salva -- maybe we should build this hack into netpyne so not visible ot user?
not exact same -- also true
did you find where this code is james?
jchen.6727 4:02 PM
I haven't searched for it yet, I'll start looking through my netpyne directory
billl 4:03 PM
think woiuld be in sim/setup.py
salvadord:speech_balloon: 4:04 PM
cell/compartCell.py or network/conn.py
billl 4:04 PM
ah thanks
sim will be runtime stuff
salvadord:speech_balloon: 4:05 PM
but isn’t this just an inefficient way of implementing it? unless needed to reproduce a model, thought should be same
ie. if use single syn with multiple netcons vs copies of same syn each with 1 netcon?
guess not since dynamics might differ…
billl 4:06 PM
generally difficult to do the summation trick -- requires having the particular type of DMS syn mech from my paper -- guess other parameterizations could do too but most cannot
salvadord:speech_balloon: 4:06 PM
depending on mod file might not be same …. right
billl 4:07 PM
the generic mod file won't work -- only works if have a bulk state var that can augment: NET_RECEIVE(weight (uS)) {
    A = A + weight*factor
    B = B + weight*factor
my paper on this -- https://paperpile.com/shared/77qZXF
alternative would be to fake it internally by keeping arrays of everything so that one mod file could incorporate multiples but then need a whole extra management for that
generally any complicated markov model of a syn will not lend itself to adding across syns like this

** Will try out netpyne branch multiple_syns
** journal club on avalanches
self organized criticality
avalanche -- where perturbation causes avalanches of size and duration
state where perturbation causes avalanches of all sizes and durations

** implemented channel mutations and drugs

* 9.24.19

